module Public where

import Private

type Request = String
type Response = String

-- Попытка #1

-- Мы могли бы определить приложение как
--   type App1 = Request -> IO ()
-- Но такая попытка совсем никуда не годится. Потому что приложению никто не
-- даёт функцию для отправки ответа, поэтому оно должно будет пользоваться
-- какой-то глобальной функцией, а в неё нужно будет как-то передавать данные
-- соединения, по которому нужно отправлять ответ (сокет, и т.д).

type App1 = Request -> (Response -> IO ()) -> IO ()

-- Такая попытка уже лучше, можно писать вот так:

app1 :: App1
app1 r resp = do
  writeFile "/tmp/log" "Запись в лог"
  resp $ "Мой ответ на запрос " ++ show r

-- Но всё равно остаётся простор для выстрела в ногу. Можно совсем не ответить
-- на запрос:

app1' :: App1
app1' r resp = return ()

-- Попытка #2
--
-- Потребуем, чтобы функция возвращала сам ответ.

type App2 = Request -> IO Response

app2 :: App2
app2 r = do
  writeFile "/tmp/log" "Запись в лог"
  return $ "Мой ответ на запрос" ++ show r

-- Но у такой функции тоже есть проблема: приложение не может само оправить
-- ответ до того, как завершится. Например, оно могло захотеть сначала отправить
-- пользователю ответ, а потом ещё пару минут позаниматься своими делами. С такой
-- сигнатурой это сделать не получится.

-- Попытка #3
--
-- Сделаем как в первой попытке, но потребуем, чтобы приложение возвращало значение
-- Secret, которое можно получить только вызвав функцию отправки пакета.

type App3 = Request -> (Response -> IO Secret) -> IO Secret

-- Теперь всё ещё можно отправить ответ как в попытке #1

app3 :: App3
app3 r resp = do
  writeFile "/tmp/log" "Запись в лог"
  resp $ "Мой ответ на запрос " ++ show r

-- Но нельзя обмануть систему типов и завершить приложение, не отправив ответ.
-- Следующая функция не скомпилируется. Так как модуль Private не экспортирует
-- конструктор данных Secret.
--
-- app3' :: App1
-- app3' r resp = return $ Secret
